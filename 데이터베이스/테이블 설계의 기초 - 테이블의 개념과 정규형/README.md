# 테이블 설계의 기초 - 테이블의 개념과 정규형


* [테이블 설계의 기초](#테이블-설계의-기초)
* [테이블 설계 규칙](#테이블-설계-규칙)


&nbsp;
## 테이블 설계의 기초
### 테이블이란
관계형 데이터베이스에서 테이블이란 2차원 표와 (거의) 같다. 테이블과 표는 매우 닮아서 양쪽 모두 열과 행으로 된 데이터 구조이다. 하지만 실제 관계형 데이터베이스에 있어 테이블은 단순히 '형식적으로 행과 열을 가지고 있으면 된다'는 정도가 아니라 좀 더 내용을 동반한 조건이 필요하다. 이 조건은 '테이블은 공통적인 요소의 집합이다', 쉽게 표현하면 테이블은 관련성 없는 것이 이것저것 모여서는 안 된다는 것이다.


### 테이블은 공통 속성을 가진 것의 집합이다
관계형 데이터베이스에서 테이블은 '어떤 공통의 속성을 가진 것의 집합'을 나타내야 하고, 이것이 테이블 설계의 제1 규칙이다. 이 규칙을 데이터베이스 세계에서는 '테이블명은 반드시 복수형이나 집합명사로 표현해야 한다'라고 표현한다.


이 규칙에 따라 채소란 공통점으로 만들어진 테이블이라면 테이블명은 'Vegetables', 제품이란 공통점으로 만들어진 테이블의 테이블명은 'Products'같은 형식이다.


### 테이블은 현실 세계를 반영한다
이 규칙의 또 한 가지의 의미는 '테이블은 현실 세계를 베낀 상이다'라는 것이다. 우리는 현실을 여러 '개념'이나 '집합'으로 구별해 인식하고 있다. 현실 세계에서 이름이 붙지 않은 잡다한 모음은 관계형 데이터베이스의 세계에도 존재하지 않는 (존재해서는 안 되는) 것이다.


&nbsp;
## 테이블 설계 규칙
'테이블은 현실 세계의 개념이나 집합을 나타낸 것'이라는 규칙을 바탕으로 테이블 설계의 일반 원칙은 바꿔 말하면 '절대로 해서는 안 되는 설계 패턴(안티 패턴)'과 같다.


### 사물과 사물의 집합은 계층이 다르다
'테이블이란 공통점을 가진 사물의 집합을 나타낸 것이다'는 테이블의 제1 규칙이다. 이 규칙을 어기면 아무런 관련성도 없는 무작위 집합이 생긴다. 이런 잡다한 '무엇이든 상자' 같은 표를 만드는 것도 당연히 안티 패턴의 한 가지이다. 이것은 사물의 '공통점'이라는 부분을 무시한 경우에 일어나는 실패지만, 또 한 가지 안티 패턴은 '사물과 집합의 계층성'을 무시하는 경우에 일어난다.


![사물과 집합의 계층성을 무시한 실패]()


위 그림에서 원래 사물인 '토마토'나 '옥수수'는 테이블의 '행'이 될 수는 있어도 '집합'을 나타내는 '테이블'이 될 수는 없다. 이 '계층성'을 무시하면 위 그림과 같은 테이블이 설계된다. 이런 테이블을 허가한다면 '오이'나 '배추' 등 새로운 채소를 추가할 때마다 새로운 테이블을 만들어야 하고 이에 대응해 애플리케이션의 코드도 바꿔야 해서 시스템 확장성은 거의 0이 된다.


아래 테이블은 어떤 서비스의 회원을 관리하는 테이블로 등록하는 정보는 회원번호, 나이, 성별 같은 기본적인 내용이다. 이 서비스에서는 회원을 '일반'과 '프리미엄' 회원으로 나누어 프리미엄 회원에는 등급이 높은 서비스를 제공한다.

**[회원 테이블]**

**회원 번호** | **나이** | **성별** | **회원구분**
----- | ----- | ----- | -----
0001 | 42 | 남 | 일반
0002 | 47 | 여 | 일반
0003 | 30 | 남 | 프리미엄
0004 | 62 | 여 | 프리미엄


기술적으로는 아래 테이블처럼 만드는 것도 가능하고 같은 방식으로 '남성' 회원 테이블과 '여성' 회원 테이블로 나누는 것도 가능하다.

**[일반]**

**회원 번호** | **나이** | **성별** 
----- | ----- | ----- 
0001 | 42 | 남
0002 | 47 | 여


**[프리미엄]**

**회원 번호** | **나이** | **성별** 
----- | ----- | ----- 
0003 | 30 | 남
0004 | 62 | 여


같은 회원 테이블을 만들더라도 집합을 나누는 방법(또는 정리하는 방법)에 따라 이렇게 3가지 가능성이 나왔다. 여기에 더해 '나이'를 기준으로 나누는 것도 가능하고 테이블을 나누는 방법이 거의 무한으로(생각하는 개념 수만큼) 존재한다.


테이블의 구성 패턴은 자의적인 구분을 고려한다면 얼마든지 늘릴 수 있다. 관계형 데이터베이스가 인간의 인식을 반영하는 거울이라는 것은 역으로 자의적으로 개념을 만들어서 집합을 나누는 인간의 자유로운 사고도 반영한다는 것이 된다. 이것이 데이터베이스 테이블 설계의 어려움이다. '인간 인식을 반영한다'란 것은 무절제한 자유도와 패턴을 허용하는 것이기도 하다.


### 가장 상위의 개념집합으로 정리한다
이런 경우 기본 규칙은 '가장 상위의 개념집합'으로 정리하는 것이다. 즉, 위 회원 테이블로 정리하고 일반과 프리미엄의 차이는 '열'로 표현하는 것이다. 이렇게 하는 이유는 이 테이블이 가장 애플리케이션에 대한 유연성이 있기 때문이다.


SQL 문의 WHERE 절로 열을 제어하면 간단하게 구현할 수 있다.


일반 회원의 선택:
```
SELECT 회원번호
FROM 회원
WHERE 회원구분 = '일반';
```


프리미엄 회원의 선택:
```
SELECT 회원번호
FROM 회원
WHERE 회원구분 = '프리미엄';
```


이처럼 WHERE 절에 조건으로 입력하는 값을 변경하는 기능을 포함하는 것은 DBMS와 프로그래밍 언어의 기능에 따라 간단히 구현할 수 있다. 이에 비해 테이블명을 바꾸는 것은 애플리케이션에 영향이 매우 크다.


### 열이란 개체의 속성이다
회원 테이블을 생각해 보면 '이름', '나이'나 '성별'은 각 회원의 고유 속성이다.


객체지향 언어로 표현한다면, 테이블은 클래스에 해당하고 각 행은 거기서 실체화된 인스턴스에 해당한다. 다만, 객체지향 언어의 클래스와는 달리 테이블은 테이블 정의에서 메서드를 가지고 있지 않아서 자신이 주체적으로 액션을 일으키지 않으며 단지 조작을 받는 수동적인 존재이다. 즉, 테이블은 '메서드를 뺀 클래스'이다.


### 현실 세계에 같은 사람은 2명 있지 않다
테이블 설계 원칙의 하나로 '반드시 기본키를 설정할 것'이란 원칙이 있다. 이것은 '한 개 테이블의 내용에는 중복 행을 허용하지 않는다'라는 의미가 된다.


관계형 데이터베이스의 테이블에서는 반드시 레코드를 1행으로 특정할 수 있는(고유하게 식별 가능한) 정보가 필요하다. 이것이 기본키 열이다. 기본키는 한 개의 테이블에 반드시 한 개만 존재해야 한다. 회원 테이블이라면 '회원 ID'나 '회원번호'같은 절대로 중복하지 않는 숫자나 문자열에 의한 기본키를 할당하는 것이 일반적이다.


**[기본키가 있다면 회원을 구분할 수 있다]**

**_ 회원ID(기본키) _** | **이름** | **나이** | **성별** | **회원구분**
----- | ----- | ----- | ----- | -----
A001 | 김민구 | 42 | 남 | 일반
A002 | 김미경 | 47 | 여 | 일반
B001 | 박유안 | 30 | 남 | 프리미엄
B002 | 이관식 | 62 | 여 | 프리미엄


### 기본키 할당은 관리의 기본
데이터베이스 사용 여부와 관계없이 데이터를 고유하게 식별할 수 있는 기본키를 할당하는 것은 데이터 관리의 기본이다. 일반적으로 테이블을 표 형식으로 나타낼 때는 기본키의 열 명에 밑줄(언더라인)을 그어 표시하는 것이 일반적이다.


### 기본키는 중복되면 안 된다
기본키로 사용하는 열은 중복이 발생하지 않는 값을 할당해야 한다. 이런 점에서 현실 세계에서 사용하는 '이름'은 기본키로는 부적절한 경우가 많다. 이름이 동성동명인 경우도 있고 이름이 바뀌는 경우도 있다. 이 결함은 중복이 없는(유일성이 유지되는) 이름의 집합에서도 내포하고 있다.


예를 들어, 대한민국의 시, 도 행정구역은 전체 15개로 중복 없는 이름이 선택되어 있지만 미래에 행정구역의 이름이 바뀌지 않는다는 보장은 없다.


### 기본키의 값이 바뀌면 왜 곤란한가
기본키 값이 바뀌면 곤란한 이유
* 변경 후 값의 유일성을 보증할 수 없다.
* 과거 데이터와의 결합(매칭)이 어렵다.


데이터 관리는 '등록한 그 시점에만 정합성이 있어야 하는' 것이 아닌 '장기적으로 정합성을 얻는 노력을 해야 하는' 것이다. 다시 말하면, 테이블 설계는 데이터가 '정적'이지 않고 '동적'임을 전제로 생각해야 한다.


> **NOTE 기본키 관리가 엄격하지 않아도 괜찮은 예**
>
> 테이블 설계는 데이터가 정적이지 않고 동적인 경우를 전제로 생각해야 한다고 했는데, 뒤집어 말하면 완전히 정적인 데이터, 즉 데이터 등록 후 변경이 전혀 없는 타입의 데이터라면 기본키 관리가 엄격하지 않아도 된다. 예로는 '이력 데이터'가 있다.


&nbsp;
&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [데이터베이스 첫걸음](http://book.naver.com/bookdb/book_detail.nhn?bid=11154846)

