# 테이블 설계의 기초 - 테이블의 개념과 정규형


* [테이블 설계의 기초](#테이블-설계의-기초)
* [테이블 설계 규칙](#테이블-설계-규칙)
* [정규형](#정규형)


&nbsp;
## 테이블 설계의 기초
### 테이블이란
관계형 데이터베이스에서 테이블이란 2차원 표와 (거의) 같다. 테이블과 표는 매우 닮아서 양쪽 모두 열과 행으로 된 데이터 구조이다. 하지만 실제 관계형 데이터베이스에 있어 테이블은 단순히 '형식적으로 행과 열을 가지고 있으면 된다'는 정도가 아니라 좀 더 내용을 동반한 조건이 필요하다. 이 조건은 '테이블은 공통적인 요소의 집합이다', 쉽게 표현하면 테이블은 관련성 없는 것이 이것저것 모여서는 안 된다는 것이다.


### 테이블은 공통 속성을 가진 것의 집합이다
관계형 데이터베이스에서 테이블은 '어떤 공통의 속성을 가진 것의 집합'을 나타내야 하고, 이것이 테이블 설계의 제1 규칙이다. 이 규칙을 데이터베이스 세계에서는 '테이블명은 반드시 복수형이나 집합명사로 표현해야 한다'라고 표현한다.


이 규칙에 따라 채소란 공통점으로 만들어진 테이블이라면 테이블명은 'Vegetables', 제품이란 공통점으로 만들어진 테이블의 테이블명은 'Products'같은 형식이다.


### 테이블은 현실 세계를 반영한다
이 규칙의 또 한 가지의 의미는 '테이블은 현실 세계를 베낀 상이다'라는 것이다. 우리는 현실을 여러 '개념'이나 '집합'으로 구별해 인식하고 있다. 현실 세계에서 이름이 붙지 않은 잡다한 모음은 관계형 데이터베이스의 세계에도 존재하지 않는 (존재해서는 안 되는) 것이다.


&nbsp;
## 테이블 설계 규칙
'테이블은 현실 세계의 개념이나 집합을 나타낸 것'이라는 규칙을 바탕으로 테이블 설계의 일반 원칙은 바꿔 말하면 '절대로 해서는 안 되는 설계 패턴(안티 패턴)'과 같다.


### 사물과 사물의 집합은 계층이 다르다
'테이블이란 공통점을 가진 사물의 집합을 나타낸 것이다'는 테이블의 제1 규칙이다. 이 규칙을 어기면 아무런 관련성도 없는 무작위 집합이 생긴다. 이런 잡다한 '무엇이든 상자' 같은 표를 만드는 것도 당연히 안티 패턴의 한 가지이다. 이것은 사물의 '공통점'이라는 부분을 무시한 경우에 일어나는 실패지만, 또 한 가지 안티 패턴은 '사물과 집합의 계층성'을 무시하는 경우에 일어난다.


![사물과 집합의 계층성을 무시한 실패]()


위 그림에서 원래 사물인 '토마토'나 '옥수수'는 테이블의 '행'이 될 수는 있어도 '집합'을 나타내는 '테이블'이 될 수는 없다. 이 '계층성'을 무시하면 위 그림과 같은 테이블이 설계된다. 이런 테이블을 허가한다면 '오이'나 '배추' 등 새로운 채소를 추가할 때마다 새로운 테이블을 만들어야 하고 이에 대응해 애플리케이션의 코드도 바꿔야 해서 시스템 확장성은 거의 0이 된다.


아래 테이블은 어떤 서비스의 회원을 관리하는 테이블로 등록하는 정보는 회원번호, 나이, 성별 같은 기본적인 내용이다. 이 서비스에서는 회원을 '일반'과 '프리미엄' 회원으로 나누어 프리미엄 회원에는 등급이 높은 서비스를 제공한다.

**[회원 테이블]**

**회원 번호** | **나이** | **성별** | **회원구분**
----- | ----- | ----- | -----
0001 | 42 | 남 | 일반
0002 | 47 | 여 | 일반
0003 | 30 | 남 | 프리미엄
0004 | 62 | 여 | 프리미엄


기술적으로는 아래 테이블처럼 만드는 것도 가능하고 같은 방식으로 '남성' 회원 테이블과 '여성' 회원 테이블로 나누는 것도 가능하다.

**[일반]**

**회원 번호** | **나이** | **성별** 
----- | ----- | ----- 
0001 | 42 | 남
0002 | 47 | 여


**[프리미엄]**

**회원 번호** | **나이** | **성별** 
----- | ----- | ----- 
0003 | 30 | 남
0004 | 62 | 여


같은 회원 테이블을 만들더라도 집합을 나누는 방법(또는 정리하는 방법)에 따라 이렇게 3가지 가능성이 나왔다. 여기에 더해 '나이'를 기준으로 나누는 것도 가능하고 테이블을 나누는 방법이 거의 무한으로(생각하는 개념 수만큼) 존재한다.


테이블의 구성 패턴은 자의적인 구분을 고려한다면 얼마든지 늘릴 수 있다. 관계형 데이터베이스가 인간의 인식을 반영하는 거울이라는 것은 역으로 자의적으로 개념을 만들어서 집합을 나누는 인간의 자유로운 사고도 반영한다는 것이 된다. 이것이 데이터베이스 테이블 설계의 어려움이다. '인간 인식을 반영한다'란 것은 무절제한 자유도와 패턴을 허용하는 것이기도 하다.


### 가장 상위의 개념집합으로 정리한다
이런 경우 기본 규칙은 '가장 상위의 개념집합'으로 정리하는 것이다. 즉, 위 회원 테이블로 정리하고 일반과 프리미엄의 차이는 '열'로 표현하는 것이다. 이렇게 하는 이유는 이 테이블이 가장 애플리케이션에 대한 유연성이 있기 때문이다.


SQL 문의 WHERE 절로 열을 제어하면 간단하게 구현할 수 있다.


일반 회원의 선택:
```
SELECT 회원번호
FROM 회원
WHERE 회원구분 = '일반';
```


프리미엄 회원의 선택:
```
SELECT 회원번호
FROM 회원
WHERE 회원구분 = '프리미엄';
```


이처럼 WHERE 절에 조건으로 입력하는 값을 변경하는 기능을 포함하는 것은 DBMS와 프로그래밍 언어의 기능에 따라 간단히 구현할 수 있다. 이에 비해 테이블명을 바꾸는 것은 애플리케이션에 영향이 매우 크다.


### 열이란 개체의 속성이다
회원 테이블을 생각해 보면 '이름', '나이'나 '성별'은 각 회원의 고유 속성이다.


객체지향 언어로 표현한다면, 테이블은 클래스에 해당하고 각 행은 거기서 실체화된 인스턴스에 해당한다. 다만, 객체지향 언어의 클래스와는 달리 테이블은 테이블 정의에서 메서드를 가지고 있지 않아서 자신이 주체적으로 액션을 일으키지 않으며 단지 조작을 받는 수동적인 존재이다. 즉, 테이블은 '메서드를 뺀 클래스'이다.


### 현실 세계에 같은 사람은 2명 있지 않다
테이블 설계 원칙의 하나로 '반드시 기본키를 설정할 것'이란 원칙이 있다. 이것은 '한 개 테이블의 내용에는 중복 행을 허용하지 않는다'라는 의미가 된다.


관계형 데이터베이스의 테이블에서는 반드시 레코드를 1행으로 특정할 수 있는(고유하게 식별 가능한) 정보가 필요하다. 이것이 기본키 열이다. 기본키는 한 개의 테이블에 반드시 한 개만 존재해야 한다. 회원 테이블이라면 '회원 ID'나 '회원번호'같은 절대로 중복하지 않는 숫자나 문자열에 의한 기본키를 할당하는 것이 일반적이다.


**[기본키가 있다면 회원을 구분할 수 있다]**

**_ 회원ID(기본키) _** | **이름** | **나이** | **성별** | **회원구분**
----- | ----- | ----- | ----- | -----
A001 | 김민구 | 42 | 남 | 일반
A002 | 김미경 | 47 | 여 | 일반
B001 | 박유안 | 30 | 남 | 프리미엄
B002 | 이관식 | 62 | 여 | 프리미엄


### 기본키 할당은 관리의 기본
데이터베이스 사용 여부와 관계없이 데이터를 고유하게 식별할 수 있는 기본키를 할당하는 것은 데이터 관리의 기본이다. 일반적으로 테이블을 표 형식으로 나타낼 때는 기본키의 열 명에 밑줄(언더라인)을 그어 표시하는 것이 일반적이다.


### 기본키는 중복되면 안 된다
기본키로 사용하는 열은 중복이 발생하지 않는 값을 할당해야 한다. 이런 점에서 현실 세계에서 사용하는 '이름'은 기본키로는 부적절한 경우가 많다. 이름이 동성동명인 경우도 있고 이름이 바뀌는 경우도 있다. 이 결함은 중복이 없는(유일성이 유지되는) 이름의 집합에서도 내포하고 있다.


예를 들어, 대한민국의 시, 도 행정구역은 전체 15개로 중복 없는 이름이 선택되어 있지만 미래에 행정구역의 이름이 바뀌지 않는다는 보장은 없다.


### 기본키의 값이 바뀌면 왜 곤란한가
기본키 값이 바뀌면 곤란한 이유
* 변경 후 값의 유일성을 보증할 수 없다.
* 과거 데이터와의 결합(매칭)이 어렵다.


데이터 관리는 '등록한 그 시점에만 정합성이 있어야 하는' 것이 아닌 '장기적으로 정합성을 얻는 노력을 해야 하는' 것이다. 다시 말하면, 테이블 설계는 데이터가 '정적'이지 않고 '동적'임을 전제로 생각해야 한다.


> **NOTE 기본키 관리가 엄격하지 않아도 괜찮은 예**
>
> 테이블 설계는 데이터가 정적이지 않고 동적인 경우를 전제로 생각해야 한다고 했는데, 뒤집어 말하면 완전히 정적인 데이터, 즉 데이터 등록 후 변경이 전혀 없는 타입의 데이터라면 기본키 관리가 엄격하지 않아도 된다. 예로는 '이력 데이터'가 있다.


### 기본키 열로 NULL은 불가
기본키가 레코드를 고유하게 식별할 수 있는 열이란 것은 기본키 열에는 'NULL'이 존재해서는 안 된다는 뜻도 있다. NULL은 어떤 레코드의 특정 열에 대해 값이 불명확하거나 값을 정하는 것이 가능하지 않은 경우에 사용되는 표시이다. 즉, '값이 없다'는 것을 나타내기 위한 '표시'이다.


기본키의 열인 'Primary_Key'만을 가진 테이블 'NullKey'를 작성한다:
```
CREATE TABLE NullKey
(Primary_Key INTEGER PRIMARY KEY);
````


데이터를 등록한다:
```
INSERT INTO NullKey VALUES (1);
INSERT INTO NullKey VALUES (2);
```


기본키로 NULL 데이터를 등록하면 다음처럼 오류가 반환된다:
```
INSERT INTO NullKey VALUES (NULL);
-> ERROR 1408 (23000): Column 'Primary_Key' cannot be null
```


이 오류는 '열 Primary_Key는 Null일 수 없습니다'라는 의미인데, 이처럼 기본키의 열에 NULL을 등록하려고 하면 오류가 발생해 실행할 수 없도록 제한되어 있다.


&nbsp;
## 정규형
테이블을 한마디로 정리하면 '고유한 기본키를 가진 공통점에 의해 정리된 것들의 집합'이다. 관계형 데이터베이스 세계에서는 '테이블은 이렇게 정의해야 한다'는 이론이 구축되었는데 그 기본이 되는 것이 '정규형(Normal Form)'이다.


'정규형'은 '데이터의 갱신이 발생한 경우에도 부정합이 발생하기 어려운 테이블의 형태'라는 뜻이다. 관계형 데이터베이스에서는 정규형에 레벨이 설정되어 있으며 일반적으로는 제1정규형부터 제5정규형가지 있다. 제3정규형까지만 파악하면 실무에서는 충분한다.


### 제1정규형(1NF)
제1 정규형의 정의는 '테이블 셀에 복합적인 값을 포함하지 않는다'이다. 관계형 데이터베이스에서는 이 정의에 반하는 테이블을 작성하는 것이 기술적으로 불가능하기 때문에 테이블은 전부 제1정규형을 자동으로 만족하고 있다.


'복합적인 값'이란 예를 들면 '배열'이 있다. 배열은 (사과, 귤)과 같은 복수의 값을 하나로 정리한 데이터형이다.


**[비 제1정규형 테이블]**

**_ 사원ID(기본키) _** | **이름** | **나이** | **성별** | **피부양자**
----- | ----- | ----- | ----- | -----
S001 | 김미경 | 38 | 여 | 박초롱
S002 | 박유안 | 30 | 남 | 박안나
S003 | 이관식 | 62 | 남 | (이수빈, 이수인)


**[제1정규형 테이블]**

**_ 사원ID(기본키) _** | **이름** | **나이** | **성별** 
----- | ----- | ----- | -----
S001 | 김미경 | 38 | 여
S002 | 박유안 | 30 | 남
S003 | 이관식 | 62 | 남


**_ 사원ID(기본키) _** | **_ 피부양자 번호(기본키) _** | **피부양자 이름** |
----- | ----- | -----
S001 | 1 | 박초롱
S002 | 1 | 박안나
S003 | 1 | 이수빈
S003 | 2 | 이수인


'단일값', 즉 이 이상 나누는 것이 가능하지 않은 값을 '스칼라 값'이라고 한다. 제1정규형이란 '스칼라 값 이외의 값을 포함하지 않는 테이블'이라고 말할 수도 있다.


### 테이블은 함수다
왜 관계형 데이터베이스에서는 '복합적인 값'을 셀에 넣으면 안 될까? 만약 복합적인 값을 허용하면 기본키가 있는 행의 값을 고유하게 특정할 수 없기 때문이다. 이것은 단적으로 기본키의 정의에 반하는 것이다. 제1정규형도 역시 '레코드의 단일성을 보증한다'라는 데이터 정합성의 관점에서 나온 규칙이다.


'기본키를 특정하면 어떤 레코드의 열 값 전체가 고유하게 특정된다'라는 것은 바꿔 말하면 '기본키와 그 외의 열 사이에는 함수적인 관계가 있다'라는 뜻이다.


관계형 데이터베이스의 테이블은 기본키를 '입력 값 X', 그 외의 열 값을 '출력 값 Y'로 간주하는 '입력 값과 출력 값의 대응표'이다. 예를 들면, '환율 통화별 대응표'가 있다.


**[환율 통화별 대응표]**

| **_ 교화국 통화(기본키) _** | **금액** |
----- | ----- | 
달러 | 91.41
유로 | 81.78
파운드 | 81.78
위안 | 607.39


위 환율 통화별 대응표에는 기본키인 교화국 통화를 입력(X)하면 금액(Y)이 고유하게 결정된다. 이 환율 통화별 대응표 테이블이 다음과 같은 '함수 F'의 정의가 있기 때문이다.
```
금액 = F(교환국 통화)
```


기본키와 다른 열 사이에 성립하는 함수적인 유일성을 관계형 데이터베이스에서는 '함수 종속성(Functional Dependency)'이라고 하면 다음과 같이 열을 대괄호({ })로 감싸서 화살표(->)로 연결해 표현한다.
```
{교환국 통화} -> {금액}
```


기본키가 복수의 열로 결정되는 경우 {고객기업 ID, 주분번호}같이 복수의 열 명을 대괄호 속에 기재하면 된다.


열에 복합 값이 포함되어 있으면 함수 종속성이 성립하지 않는다.


### 제2정규형(2NF)
제1정규형을 만족한 상황에서 제2정규형을 만족하지 않는 테이블을 예로 들면 아래 표와 같다.


**[주문 테이블(제2정규형 아님)]**

**_ 고객기업ID(기본키) _** | **_ 주문번호(기본키) _** | **주문접수일** | **고객기업명** | **고객기업 규모**
----- | ----- | ----- | ----- | -----
CA | 001 | 2014/12/20 | A상사 | 대규모
CA | 002 | 2014/12/21 | A상사 | 대규모
CB | 001 | 2014/12/12 | B건설 | 중규모
CB | 002 | 2014/12/25 | B건설 | 중규모
CB | 003 | 2014/12/25 | B건설 | 중규모
CC | 001 | 2014/12/1 | C화학 | 소규모


기본키는 {고객기업 ID, 주문번호}의 조합이며 이 조합으로 행을 유일하게 특정하는 것이 가능하다. {고객기업 ID}나 {주문번호} 단독으로는 고유성이 없다. {고객기업 ID}는 'CB'란 값이 3개의 행에 있어서 1행으로 특정하는 것이 불가능하다. {주문번호}도 같은 문제가 발생한다. 2개의 열을 조합해야만 고유한 키가 생기게 된다.


이 테이블은 전체 셀이 스칼라 값으로 구성되어 있어 제1정규형을 충족한다. 하지만 제2저규형은 아니다. '부분함수 종속성'이라는 함수 종속이 존재하기 때문이다. 부분함수 종속은 '기본키를 구성하는 열의 일부에만 함수 종속이 존재하는 것이다. 예를 들어, 기업의 이름은 기업 ID만 안다면 고유하게 특정할 수 있다. 기업의 규모도 마찬가지이다. 이 두열에 한정해서 본다면 {주문번호} 열은 쓸데없는 정보이다.


이와 같은 부분함수 종속이 존재할 경우 해당 키와 종속하는 열만 다른 테이블로 만들어 외부로 꺼내야 한다.


**[고객기업 주문 테이블과 고객기업 테이블(제2정규형)]**

**_ 고객기업ID(기본키) _** | **_ 주문번호(기본키) _** | **주문접수일**
----- | ----- | -----
CA | 001 | 2014/12/20
CA | 002 | 2014/12/21
CB | 001 | 2014/12/12
CB | 002 | 2014/12/25
CB | 003 | 2014/12/25
CC | 001 | 2014/12/1 



**_ 고객기업ID(기본키) _** | **고객기업명** | **고객기업 규모**
----- | ----- | ----- 
CA | A상사 | 대규모
CB | B건설 | 중규모
CC | C화학 | 소규모


이처럼 나누어진 고객기업 주문 테이블과 고객기업 테이블은 둘 다 제2정규형을 충족하고 있다. 그 증거로 전체 열이 기본키만으로도 함수 종속을 가지고 있으며 기본키의 일부에만 종속하는 열은 없다. 또한, 이 제2정규형을 '테이블은 집합이다'란 관점에서 보면 나눈 후의 고객기업 주문 테이블과 고객기업 테이블은 각각 확실하게 '주문'과 '고객'이라는 집합에 대응하고 있다. 즉, 각 행이 하나의 주문 또는 기업을 나타내고 있다.


### 제2정규형은 왜 필요한가
제2정규형은 무엇을 위해 만드는 걸까? 위 [제2정규형이 아닌 테이블]을 실무에서 사용하는 경우 어떤 불편과 위험이 발생하는지 생각해 보면 알 수 있다. 이 비정규형 테이블을 사용할 때 가장 곤란한 점은 고객 정보를 어느 정도 알고 있지 않으면 주문을 등록할 수 없다는 점이다. 또한, 같은 고객기업의 행이 복수 행 존재하므로 이 경우 일부가 잘못 등록될 위험이 있다.


갱신 시의 데이터 부정합을 '갱신 이상'이라고 한다. 비정규형 테이블은 대체로 이 갱신 이상의 위험이 높은 테이블이다. 그 이유는 테이블이 올바른 집합 단위에 기초를 두고 있지 않기 때문이다. 관계형 데이터베이스에서 아름다운 테이블이란 바로 '기능적인 테이블'이다.


### 제3정규형(3NF)


**[고객기업 테이블(제3정규형 아님)]**

**_ 고객기업ID(기본키) _** | **고객기업명** | **고객기업규모** | **업계코드** | **업계명**
----- | ----- | ----- | ----- | -----
CA | A상사 | 대규모 | D001 | 석유
CB | B건설 | 중규모 | D002 | 건설
CC | C화학 | 소규모 | D003 | 바이오


위 표는 '고객기업 테이블'에 해당 기업이 속하는 업계의 정보를 덧붙인 테이블이다. 제1정규형은 만족하며 기본키가 '고객기업 ID' 한 개의 열이라서 제2정규형도 만족한다(기본키가 1개 열밖에 없는 경우 자동으로 제2정규형을 만족하게 된다).


하지만 이 테이블에도 역시 갱신 이상이 존재한다. 예를 들어, 앞으로 관리하고 싶은 업계는 석유, 건설, 바이오 외에도 시스템 또는 유통 등 다양하다고 해도 지금은 이 테이블에 해당 업계를 등록할 방법이 없다. 이 테이블이 '기업'이라는 단위의 집합을 반영하고 있어서 '유통'이라는 업계에 속한 기업과 거래를 하지 않은 이상 해당 업계의 레코드를 만들 수 없기 때문이다.


이와 같은 사태가 발생한 이유는 이 테이블에도 한 개의 함수 종속, 즉 '추이함수 종속'을 가져왔기 때문이다. 이것은 기본키 이외의 키 간에 발생하는 함수 종속으로 다음의 종속성이 해당한다:
```
{업계코드} -> {업계명}
```


'추이함수 종속'에 '추이'라는 이름이 붙은 것은 다음처럼 기본키에서 볼 때 2단계의 함수 종속이 존재하기 때문이다:
```
{고객기업 ID} -> {업계코드} -> {업계명}
```


이와 같은 함수 종속도 제2정규형과 동일하게 테이블을 나누어 외부로 빼놓아야 한다.


**[고객기업 테이블(제3정규형)과 업계 테이블(제3정규형)]**

**_ 고객기업ID(기본키) _** | **고객기업명** | **고객기업규모** | **업계코드**
----- | ----- | ----- | -----
CA | A상사 | 대규모 | D001
CB | B건설 | 중규모 | D002
CC | C화학 | 소규모 | D003


**_ 업계코드(기본키) _** | **업계명**
----- | -----
D001 | 석유 
D002 | 건설
D003 | 바이오


이제는 '업계 테이블'에 (아직 거래가 없는 업계라 할지라도) 원하는 만큼 새로운 업계를 추가할 수 있다. 위 비정규형 테이블은 '기업'과 '업계'라는 명백히 계층이 다른 집합들을 하나의 테이블에서 관리하려 했다. 이것을 간단하고 깔끔하게 나누어서 관리하려고 하면 자연히 '제3정규형'에 도달게 된다. 


&nbsp
## ER 다이어그램
테이블 간의 관련성을 한눈에 알 수 있게 고안된 기술이 ER 다이어그램(Entity-Relationship Diagram)이다. 'Entity(엔티티, 실체)'란 '테이블', 'Relationship(릴레이션십, 관계, 관련성)'이란 '테이블 간의 관계'를 의미한다. 이를 표시하는 데 그래픽으로 이해하기 쉽도록 해주는 기술이 ER 다이어그램이다.


'IE(Information Engineering)'란 표기법은 ER 다이어그램을 그리는 방법으로 대중적인 데다가 알기 쉽고 직관적으로 이해하기 쉬운 이점이 있다.


### 엔터티란
'엔터티'는 간단히 설명하면 테이블과 같고, 사각형으로 표시한다.


[**업계 테이블의 엔터티**]

업계코드(PK) |
----- |
업계명 |


위 절반의 부분에는 '기본키'를 아래 절반의 부분에는 '기타 열(기본키가 아닌 열)'을 기재한다. 'PK'는 'Primary Key'의 줄임말이다. 실제로 기본키가 아닌 열을 매우 수가 많으므로 업무적으로 중요한 의미를 가진 열만을 택해서 작성한다.


![고객기업 테이블의 엔터티]()


'FK'



&nbsp;
&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [데이터베이스 첫걸음](http://book.naver.com/bookdb/book_detail.nhn?bid=11154846)

