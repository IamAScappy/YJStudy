# DBMS를 조작할 때 필요한 기본 지식 - 조작하기 전에 알아두어야 할 것


* [데이터베이스에 연결하기](#데이터베이스에-연결하기)
    * [커넥션](#커넥션)
    * [커넥션의 상태를 조사하는 명령](#커넥션의-상태를-조사하는-명령)
    * [로그오프](#로그오프)
* [SQL과 관리 명령의 차이](#sql과-관리-명령의-차이)
    * [관리 명령이란](#관리-명령이란)
    * [관리 명령에서 기억해야 할 점](#관리-명령에서-기억해야-할-점)
* [관계형 데이터베이스의 계층](#관계형-데이터베이스의-계층)
    * [폴더에 해당하는 스키마](#폴더에-해당하는-스키마)
    * [최상위에 있는 인스턴스](#최상위에-있는-인스턴스)
    * [MySQL과 Oracle의 계층 구조](#mysql과-oracle의-계층-구조)


&nbsp;
## 데이터베이스에 연결하기
### 커넥션
커넥션은 전화를 떠올려보면 이해하기 쉽다. 누군가와 전화로 이야기하려면 다음 3단계를 밟아야 한다.
1. 상대방의 전화번호를 입력한다.
2. 전화를 건다.
3. 상대방이 전화를 받는다.


이 3단계를 통해 만들어진 연결이 '커넥션'이다. 커넥션이 유지되는 동안에는 대화할 수 있다. 데이터베이스도 마찬가지로 커넥션이 유지되는 한 사용자는 데이터베이스와 무언가를 주고받을 수 있다. 말하자면 '로그인'이라는 행위는 상대방을 호출하는 행위와 같다.


![DBMS에서 로그인과 커넥션](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/DBMS를%20조작할%20때%20필요한%20기본%20지식%20-%20조작하기%20전에%20알아두어야%20할%20것/images/DBMS에서%20로그인과%20커넥션.jpg)
&nbsp;


MySQL에 로그인했을 때에 표시되는 메시지에도 다음과 같이 커넥션이 성립되었음을 표시하는 문장이 있다.
```
Your MySQL connection id is 11
```


'connection id'는 MySQL이 사용자의 커넥션에 붙인 번호로, MySQL은 동시에 여러 개의 커넥션을 유지하는 것이 가능(동시에 복수의 사용자와 연결하는 것이 가능하다)해서 이렇게 번호로 관리하지 않으면 어떤 커넥션이 어느 사용자를 위한 것인지를 모르게 된다.


커넥션의 시작과 종료 사이에 DBMS와 다양한 교환을 하게 되는데, 그 교환의 시작과 종료까지의 단위를 '세션(Session)'이라고 한다. 커넥션과 세션은 매우 유사한 개념이라서 같은 의미로 사용되는 경우도 많지만, 정확하게는 커넥션이 확립된 후에 세션이 만들어진다.


### 커넥션의 상태를 조사하는 명령
거의 모든 DBMS에는 커넥션의 상태나 수를 조사하기 위한 명령어(커맨드)를 준비해 두고 있다. MySQL의 경우 'show status'라는 명령어를 사용한다.
```
mysql> show status like 'Threads_connected';
```


사용자가 1명밖에 로그인하지 않았다면 다음과 같은 결과가 표시될 것이다. 이때 또 한 명의 누군가가 MySQL에 로그인했다면 'Threads_connected'의 값은 '2'가 된다.
```
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| Threads_connected | 1     |
+-------------------+-------+
```


이처럼 복수의 사용자가 동시에 (다른 사용자를 의식하지 않고)작업을 실행할 수 있다는 것이 데이터베이스를 이용하는 이점의 하나이다.


### 로그오프
로그오프를하면 MySQL과의 커넥션이 끊어진다. 로그오프 명령은 프롬프트 상태에서 'quit'라고 입력하면 된다.
```
mysql> quit
Bye
```


&nbsp;
## SQL과 관리 명령의 차이
### 관리 명령이란
DBMS는 SQL 이외에도 다양한 용도의 명령어를 준비해 두고 있는데, 이것은 '관리 명령'이라고 한다. 예를 들어, 앞에서 사용한 show status가 이에 해당한다.


show status는 '상태를 살펴본다'란 의미 그대로 MySQL의 상태에 대한 여러 정보를 보기 위해 사용할 수 있다.


MySQL이 가동된 시점부터의 경과시간(초):
```
mysql> show status like 'Uptime';

+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Uptime        | 6118  |
+---------------+-------+
```


MySQL이 실행한 SQL 문의 수:
```
mysql> show status like 'Queries';

+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Queries       | 13    |
+---------------+-------+
```


### 관리 명령에서 기억해야 할 점
관리 명령은 DBMS가 정상적으로 동작하는지 감시하거나 DBMS가 이상한 동작을 할 때 문제 해결을 위해 정보수집을 하는 등의 용도로 사용한다.


관리 명령에서 중요한 점은 다음의 2가지이다:
* DBMS는 SQL 문 이외에도 '관리 명령'이 있다.
* 관리 명령의 종류나 문법은 DBMS에 따라 다르다.


SQL 문은 표준 구문을 이용하는 한 MySQL 이외의 DBMS라도 공통적으로 사용할 수 있지만, 관리 명령은 공통 부분이 적다.


SQL 문과 관리 명령은 어떻게 구분할 수 있을까? 아주 간단하게 다음 규칙으로 나눌 수 있다.
* SQL 문은 반드시 'SELECT, INSERT, DELETE, UPDATE' 중 하나의 단어로 시작한다.
* 이 외의 단어로 시작한다면 관리 명령이다.


&nbsp;
## 관계형 데이터베이스의 계층
데이터베이스 내부의 테이블은 1개가 아닌 몇 개의 그룹으로 나뉘어서 관리된다. PC에서 파일을 분류하기 위해 사용하는 '폴더(디렉터리)'에 해당하는 것이 데이터베이스에도 있다고 생각하면 된다.


### 폴더에 해당하는 스키마
데이터베이스에서 이 폴더에 해당하는 것이 '스키마(Schema)'이다. 테이블은 실제로 몇 개의 스키마 속에 저장되는 형식을 취하고 있다. 스키마도 폴더처럼 사용자가 자유롭게 만들 수 있어서 용도별로 나누거나 보여주고 싶지 않은 사용자에게는 접근할 수 없도록 제한을 건 스키마를 만드는 등의 권한 관리를 수행하는 것도 가능하다.


스키마의 상위에는 또 하나의 계층으로 '데이터베이스(Database)'가 있다.


### 최상위에 있는 인스턴스
마지막으로 데이터베이스보다 한 층 더 위에 있는 '인스턴스(Instance)'란 개념이 있다. 이것은 물리적 개념으로, DBMS가 동작할 때의 단위이다. 그래서 OS 입장에서는 '프로세스'라고도 부른다. DBMS에 따라서는 이것을 '서버 프로세스' 또는 단순히 '서버'로 부르는 경우도 있다. 여기에서 인스턴스는 메모리나 CPU를 사용하는 존재로 OS에 존재하는 '실체'라는 의미이다.


1개의 인스턴스 아래에는 복수 개의 데이터베이스가 존재할 수 있고, 1개의 데이터베이스의 아래에는 복수의 스키마가 존재할 수 있으며, 1개의 스키마 아래에는 복수 개의 테이블이 존재하는 것이 가능하다.


![관계형 데이터베이스의 계층 구조](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/DBMS를%20조작할%20때%20필요한%20기본%20지식%20-%20조작하기%20전에%20알아두어야%20할%20것/images/관계형%20데이터베이스의%20계층%20구조.jpg)
&nbsp;


> **NOTE. 4계층에 있는 것**
>
> 최하위 계층인 4계층에는 테이블 이외의 것이 있다. '인덱스(Index)', 다양한 함수나 처리를 일괄로 다루는 '저장 프로시저(Stored Procedure)' 등이다. 이런 데이터베이스에 보존된 것들을 총칭해서 '오브젝트(Object)'라고 한다. 테이블도 물론 오브젝트의 일종이다. 또한, 인스턴스도 복수로 존재할 수 있으며 이 경우 '멀티 인스턴스'라는 구성을 사용한다.


&nbsp;

계층 구조는 여기까지 설명한 대로지만 이건 어디까지나 원칙이고, 현실에서는 구현되는 것마다 조금씩 차이가 있다. 이 계층의 원칙을 충실히 지키는 DBMS는 PostgreSQL, SQL Server, DB2고, 스키마와 데이터베이스 한 계층을 생략한 것이 MySQL과 Oracle이다.


### MySQL과 Oracle의 계층 구조
MySQL은 데이터베이스와 스키마를 동일한 것으로 간주해서 계층 차이를 두지 않으므로 데이터베이스와 스키마는 MySQL에서는 동의어이다.


![MySQL의 계층 구조](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/DBMS를%20조작할%20때%20필요한%20기본%20지식%20-%20조작하기%20전에%20알아두어야%20할%20것/images/MySQL의%20계층%20구조.jpg)


&nbsp;

Oracle은 조금 달라서 4계층 구조로 되어 있지만, '인스턴스 아래에 데이터베이스를 한 개만 만들 수 있다'는 독자적 제약이 있어서 실질적으로 데이터베이스를 의식하지 않으며 3계층 구조로 바뀌지도 않는다.


![Oracle의 계층 구조](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/DBMS를%20조작할%20때%20필요한%20기본%20지식%20-%20조작하기%20전에%20알아두어야%20할%20것/images/Oracle의%20계층%20구조.jpg)


&nbsp;

정리하면 관계형 데이터베이스의 계층 구조는 다음과 같이 두 파로 나뉜다.
* 3계층: Oracle, MySQL
* 4계층: SQL Server, DB2, PostgreSQL


3계층과 4계층 중 어느 쪽이 맞는지 묻는다면 답은 4계층이다. 이는 ANSI가 정한 표준 SQL로 결정되어 있기 때문이다. 하지만 독자 노선의 3계층 사양에도 특별한 불편함은 없다.


&nbsp;
> **NOTE. 멀티 인스턴스와 가상화**
>
> 데이터베이스의 계층 구조에서 인스턴스는 최상위 개념이다. 그러면 인스턴스를 한 개의 OS에서 복수로 존재하게 하는 것이 가능할까? 원칙적으로 가능하며, 이런 구성을 '멀티 인스턴스(Multi Instance)'라고 부른다.
>
> 다만 '원칙적으로'라고 한 것은 이유가 있다. 인스턴스는 OS에서 보면 메모리나 CPU 등의 물리 자원을 소비하는 프로세스이기 때문에 복수의 인스턴스를 존재하게 할 여력이 자원에 없다면 멀티 인스턴스를 만들려고 해도 만들 수 없기 때문이다. 특히 CPU 파워가 부족하다면 처리가 늦어지는 정도지만, 메모리가 부족한 경우는 인스턴스의 기동조차 하지 못하고 오류가 발생하는 경우도 있다(이것은 DBMS가 일반적으로 기동 시에 최저 한계의 메모리 공간을 확보하려고 하기 때문이다).
>
> 멀티 인스턴스의 구성을 채용하는 것은 어떤 경우일까? 테스트 환경을 복수로 준비하고 싶지만, 물리 서버 대수가 부족한 경우 정도이다. 그렇지만 그런 용도라면 1대의 인스턴스 내에 데이터베이스를 여러 개 만들면 되고, 최근에는 가상화 환경을 사용하는 예도 늘고 있다. 앞으로도 멀티 인스턴스 사용은 줄 것으로 예측된다.


&nbsp;
&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [데이터베이스 첫걸음](http://book.naver.com/bookdb/book_detail.nhn?bid=11154846)

