# 트랜잭션과 동시성 제어 - 복수의 쿼리 통합


* [트랜잭션이란](#트랜잭션이란)
    * [트랜잭션](#트랜잭션)
* [다른 커넥션에서는 어떻게 보일지 생각해 보자](#다른-커넥션에서는-어떻게-보일지-생각해-보자)
    * [다른 커넥션에서 테이블을 본다](#다른-커넥션에서-테이블을-본다)
* [트랜잭션 격리 수준에 따른 외관상 차이](#트랜잭션-격리-수준에-따른-외관상-차이)
    * [MVCC에 따른 MySQL의 특성](#mvcc에-따른-mysql의-특성)
    * [트랜잭션 격리 수준별 외관](#트랜잭션-격리-수준별-외관)
* [잠금 타임아웃과 교착 상태가 발생하는 이유](#잠금-타임아웃과-교착-상태가-발생하는-이유)
    * [잠금 타임 아웃이란](#잠금-타임-아웃이란)
    * [교착 상태란](#교착-상태란)
    * [교착 상태의 빈도를 낮추는 대책](#교착-상태의-빈도를-낮추는-대책)
* [해서는 안 되는 트랜잭션 처리](#해서는-안-되는-트랜잭션-처리)
    * [주의1. 오토커밋](#주의1-오토커밋)
    * [주의2. 긴 트랜잭션](#주의2-긴-트랜잭션)


&nbsp;
## 트랜잭션이란
### 트랜잭션
테이블 갱신을 수행하기 위해 'INSERT/DELETE/UPDATE'를 사용했는데, 갱신은 단일 쿼리만으로 구성된 것이 아니고 복수 쿼리를 연속적으로 수행하는 경우가 대부분이다. 또한, 갱신 전의 데이터로 SELECT를 사용할 때 이를 포함해 복수 쿼리를 일관된 형태의 한덩어리로 다뤄야 한다. 트랜잭션이란 이런 복수 쿼리를 한 단위로 묶은 것이다.


MySQL에서는 트랜잭션을 사용할 수 없는 단순한 구조의 'MyISAM형'과 일반적인 DBMS와 똑같은 트랜잭션 구조를 사용할 수 있는 'InnoDB형' 2종류의 테이블을 이용할 수 있다.


트랜잭션은 'ACID 특성'이라고 불리는 다음 4가지 특성으로 정의된다.
1. Atomicity(원자성)
2. Consistency(일관성)
3. Isolation(고립성 또는 격리성)
4. Durability(지속성)


#### 원자성
'원자성(Atomicity)'이란 데이터의 변경(INSERT/DELETE/UPDATE)을 수반하는 일련의 데이터 조작이 전부 성공할지 전부 실패할지를 보증하는 구조이다.


예를 들어, 서울에서 KTX로 부산까지 가서 일박하고 다음 날 서울로 돌아오는 경우를 생각해 보자.
1. 서울 -> 부산행 좌석을 예매한다.
2. 부산에서의 숙박을 예약한다.
3. 부산 -> 서울행 좌석을 예매한다.
4. 1~3의 대금을 지급한다.


이런 절차가 모두 잘 진행되면 트랜잭션에서는 1~4를 처리한 후에 'COMMIT'을 실행해 처리를 확정한다. 이 경우 각 데이터의 조작은 영구적으로 저장되어 결과가 손실되지 않는다.


그러면 처리 도중에서 오류가 발생하는 경우는 어떨까? 3에서 좌석을 예매할 수 없다든지 4에서 보유한 돈이 부족한 경우에는 'ROLLBACK'을 실행해 1~4의 처리 과정 중 1의 직전 상태까지 되돌아갈 수 있다. 또한, 이렇게 시스템이 정상 동작하는 상황에서의 오류뿐만 아니라 클라이언트에서 서버로의 통신이 끊긴다거나 서버가 다운된 경우에도 COMMIT 된 것 이외는 ROLLBACK을 해야 한다.


![전부 성공하거나 전부 실패하거나](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/트랜잭션과%20동시성%20제어%20-%20복수의%20쿼리%20통합/images/전부%20성공하거나%20전부%20실패하거나.jpg)


#### 일관성
데이터베이스에는 데이터베이스 오브젝트(테이블을 비롯해 데이터베이스 내에 정의할 수 있는 오브젝트)에 대해 각종 정합성 제약을 추가할 수 있다. 이는 일련의 데이터 조작 전후에 그 상태를 유지하는 것을 보증하는, 즉 '일관성(Consistency)'을 유지하기 위한 구조이다. 


예를 들면, 시스템에 사용자를 등록할 때 사용자를 임의로 식별하기 위해 일련번호(사용자 번호)를 사용자에게 발급한다. 이때 이 번호에 유니크 제약(유일성 제약)을 설정하면 중복된 사용자 번호를 저장할 수 없다. 이것은 복수의 사용자가 동시에 사용자 번호를 취득하려는 경우에도 마찬가지이다.


#### 고립성
'고립성(격리성, Isolation)'이란 일련의 데이터 조작을 복수 사용자가 동시에 실행해도 '각각의 처리가 모순 없이 실행되는 것을 보증한다'는 것이다.


예를 들면, 부산의 지정 호텔에 남은 싱글룸 수가 10개였을 때 실제로 숙박한 흐름을 프로그래밍하듯이 표현하면 다음과 같다.
1. 현재 빈 싱글룸의 수를 확인한다(SELECT).
2. 빈 싱글룸 수에서 1을 빼고 결과를 빈 싱글룸 수로 되돌려 쓴다(UPDATE)


이것을 사용자 A와 B가 동시에 수행하면 어떻게 될까? 2명이 방을 확보한다면 원래 빈 싱글룸 수는 2개가 줄어야 하지만, 같은 방을 동시에 확보하게 되면 빈 싱글룸 수는 1개만 줄어들게 된다.


![빈 싱글룸 수가 올바르지 않은 시나리오](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/트랜잭션과%20동시성%20제어%20-%20복수의%20쿼리%20통합/images/빈%20싱글룸%20수가%20올바르지%20않은%20시나리오.jpg)


이런 사태가 발생하는 것을 막기 위해 데이터베이스에는 데이터베이스 오브젝트인 테이블에 대해 '잠금(Lock)'을 걸어서 후속 처리를 블록(Block)하는 방법이 있다. 잠금 단위네는 테이블 전체, 블록, 행 등이 있는데, MySQL에서는 트랜잭션 처리를 할 때 주로 행 단위의 잠금 기능을 이용한다.


예를 들어, '1. 현재 빈 싱글룸 수를 확인한다'를 처리할 때 'SELECT ~ FOR UPDATE'를 실행하면 SELECT한 행에 잠금이 걸린다. 이렇게 되면 후속 처리는 해당 잠금이 해제될 때(COMMIT 또는 ROLLBACK, 여기서는 COMMIT)까지 대기하게 되며 올바른 처리를 계속할 수 있게 된다.


![빈 싱글룸 수가 바르게 처리되는 시나리오](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/트랜잭션과%20동시성%20제어%20-%20복수의%20쿼리%20통합/images/빈%20싱글룸%20수가%20바르게%20처리되는%20시나리오.jpg)


InnoDB형의 테이블은 'MVCC'라는 구조로 동작하기 때문에 사용자 B가 단순히 값을 참조하는 경우에는 SELECT에 FOR UPDATE는 불필요하며 이 경우 읽기는 블록되지 않는다. 테이블을 갱신하는 사용자가 소수고 참조하는 사용자가 많은 경우에는 사용자의 동시성, 병렬성이 높아진다.


어떤 상태를 '모순 없다'라고 할 수 있을까? 이에 대한 답은 '복수의 트랜잭션이 순서대로 실행되는 경우와 같은 결과를 얻을 수 있는 상태'이다. 병렬로 실행되지 않는(직렬) 상태를 말하며, 이와 같으면 모순 없음을 보장할 수 있다.


이것을 DBMS에서 격리 수준(Transaction Isolation Level)으로 구현하고 제공하는 것이 '직렬화 가능(Serializable)'이라는 사양이다. 하지만 직렬화 가능의 고립성에서는 항상 동시에 동작하는 트랜잭션이 1개의 이미지가 되어 성능면에서 실용적이지 않다. 이 때문에 직렬화 가능으로부터 격리 수준을 완화해 직렬화 가능 이외에 자신이 아닌 다른 트랜잭션의 영향받는 것을 허용하는 4개의 단계를 ANSI에서 정의했다.
1. 커밋되지 않은 읽기(Read Uncommitted, 리드 언커밋티드)
2. 커밋된 읽기(Read Committed, 리드 커밋티드)
3. 반복 읽기(Repeatable Read, 리피터블 리드)
4. 직렬화 가능(Serializable, 시리얼라이저블)


이중 4의 직렬화 가능이 가장 엄격하며 1의 커밋되지 않은 읽기가 가장 완화된 격리 수준이다. 그러나 격리 수준이 완화되면서 직렬화 가능에서는 발생하지 않았던 현상이 생긴다.


격리 수준의 완화에 따라 일어나는 현상:


**현상** | **개요**
----- | -----
더티 읽기(Dirty Read) | 어떤 트랜잭션이 커밋되기 전에 다른 트랜잭션에서 데이터를 읽는 현상이다. 예를 들면, 사용자 A가 값을 변경하고 아직 커밋하지 않아도 사용자 B가 변경한 후의 값을 읽는 것을 가리킨다. 확정 전의 '더렵혀진(Dirty)' 데이터를 읽는 것에서 붙여진 이름이다.
애매한 읽기(Fuzzy/NonRepeatable Read) | 어떤 트랜잭션이 이전에 읽어 들인 데이터를 다시 읽어 들일 때 2회 이후의 결과가 1회 때와 다른 현상이다. 예를 들면, 최초에 사용자 A가 빈 싱글룸 수 '10'을 읽고 그 후 사용자 B가 값을 '9'로 변경해 커밋했다고 하자. 계속해서 사용자 A가 SELECT를 다시 실행하면 최초에 SELECT했던 '10'이 아닌 변경 후의 '9'를 읽어 들이게 된다. 사용자 A가 최초에 읽은 값 '10'이 2회 이후의 SELECT에서 보증되지 못하고 애매하게(Fuzzy) 되는 것에서 붙여진 이름이다.
팬텀 읽기(Phantom Read) | 어떤 트랜잭션을 읽을 때 선택할 수 있는 데이터가 나타나거나 사라지는 현상이다. 최초에 사용자 A가 범위 검색(예를 들면, 빈 싱글룸 수가 10 이상의 호텔)을 수행 후 3행을 읽었다고 가정하자. 계속해서 사용자 B가 막 그 범위에 들어가는 데이터 1행을 INSERT하고 커밋도 실행했다. 계속해서 사용자 A가 다시 같은 SELECT 문을 실행하면 최초에 SELECT해서 얻었던 3행이 아닌 4행이 선택된다. 이처럼 나타나거나 사라지는(DELETE나 UPDATE로 사라진다) 데이터가 '유령(Phantom)'과 닮아서 붙여진 이름이다.


3가지 현상과 격리 수준의 관계:
**격리 수준** | **더티 읽기** | **애매한 읽기** | **팬텀 읽기**
----- | ----- | ----- | ----- | -----
커밋되지 않은 읽기 | O | O | O
커밋된 읽기 | X | O | O
반복 읽기 | X | X | O
직렬화 기능 | X | X | X


#### 지속성
'지속성(Durability)'은 일련의 데이터 조작(트랜잭션 조작)을 완료(COMMIT)하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지 않는 것을 나타낸다. 이것은 시스템이 정상일 때만이 아니라 데이터베이스나 OS의 이상 종료, 즉 시스템 장애도 견딜 수 있다는 뜻이다. 


MySQL을 포함해 많은 데이터베이스의 구현에서는 트랜잭션 조작을 하드 디스크에 '로그'로 기록하고 시스템에 이상이 발생하면 그 로그를 사용해 이상 발생 전의 상태까지 복원하는 것으로 지속성을 실현하고 있다.


&nbsp;
## 다른 커넥션에서는 어떻게 보일지 생각해 보자
### 다른 커넥션에서 테이블을 본다
기본으로 데이터 정의 언어(DDL, Data Definition Language)에 따른 테이블 작성과 데이터 조작 언어(DML, Data Manipulation Language)에 의한 데이터 저장은 트랜잭션이 커밋되기 전까지 다른 커넥션에서 보이지 않는다. 그런데 이에 상관없이 다른 커넥션에서 보이는 이유가 있다.


#### 1. DDL에 따른 암묵적인 커밋
MySQL이나 Oracle에서는 CREATE TABLE과 같은 DDL 실행 시 암묵적인 커밋이 발행한다. 한 개의 커넥션에서 실행된 CREATE TABLE이 성공하면 그 이후에는 다른 커넥션에서도 참조 할 수 있게 된다.


#### 2. 오토커밋 설정
트랜잭션의 개시(BEGIN TRANSACTION, START TRANSACTION, SET TRANSACTION 등)가 명시적으로 지정되지 않았을 때 트랜잭션을 구별하는 방법으로 다음 2가지 모드가 있다.
1. 하나의 SQL 문이 하나의 트랜잭션으로 구분된다. = 오토커밋(Auto Commit) 모드
2. 사용자가 COMMIT 또는 ROLLBACK을 실행하기까지가 하나의 트랜잭션이 된다.


기본 설정이 오토커밋 모드인 DBMS에는 MySQL, PostgreSQL, SQL Server 등이 있다.


&nbsp;
> **NOTE** DDL, DML, DCL
>
> **데이터 정의 언어**(DDL, Data Definition Language)
>
> DDL은 데이터를 저장하는 그릇인 스키마(데이터베이스) 또는 테이블 등을 작성하거나 제거한다. DDL로 구분된 명령에서는 'CREATE(데이터베이스나 테이블의 작성)' 외에 'DROP(CREATE로 작성한 것을 제거)', 'ALTER(CREATE로 작성한 것을 변경)' 등이 있다.
>
> **데이터 조작 언어**(DML, Data Manipulation Language)
>
> DML은 테이블의 행을 검색하거나 변경하는 데 사용할 수 있다. DML로 구분된 명령에는 'SELECT(행의 검색), INSERT(행의 추가), UPDATE(행의 갱신), DELETE(행의 제거)' 등이 있다.
>
> **데이터 제어 언어**(DCL, Data Control Language)
>
> DCL은 데이터베이스에서 실행한 변경을 확정하거나 취소하는 데 사용한다. 'COMMIT(변경의 확정)'이나 'ROLLBACK(변경의 취소)'는 DCL의 일종이다.
>
> SQL 명령은 DDL, DML, DCL 3가지로 구분되며, SQL 문 대부분은 DML이다.


트랜잭션을 다룰 수 있는 테이블 작성하기:
```
// InnoDB형의 테이블 t1이 작성된다.
create table t1(i1 int not null primary key, v2 varchar(20)) engine = innodb;

// 행을 추가한다.
insert into t1 values(1, 'Firebird');

show create table t1\G
*************************** 1. row ***************************
Table: t1
Create Table: CREATE TABLE `t1` (
`i1` int(11) NOT NULL,
`v2` varchar(20) DEFAULT NULL,
PRIMARY KEY (`i1`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)
```


&nbsp;
## 트랜잭션 격리 수준에 따른 외관상 차이
### MVCC에 따른 MySQL의 특성
MySQL(InnoDB형 테이블)은 현재 DBMS의 주류가 된 'MVCC(Multi Versioning Concurrency Control)'라는 기술을 사용하고 있다. MVCC를 사용하기 때문에 MySQL은 다음 특성을 가진다.
1. 읽기를 수행할 경우 갱신 중이라도 블록되지 않는다(일긱와 읽기도 서로 블록되지 않는다).
2. 읽기 내용은 격리 수준에 따라 내용이 바뀌는 경우가 있다.
3. 갱신 시 배타적 잠금을 얻는다. 잠금은 기본적으로 행 단위로 얻으며 트랜잭션이 종료할 때까지 유지한다.
4. 갱신과 갱신은 나중에 온 트랜잭션이 잠금을 획득하려고 할 때 블록된다. 일정 시간을 기다리며 그 사이에 잠금을 획득할 수 없는 경우에는 '잠금 타임아웃(Lock Timeout)'이 된다.
5. 갱신하는 경우 갱신 전의 데이터를 UNDO 로그로 '롤백 세그먼트'라는 영역에 유지한다. 'UNDO 로그'는 용도가 2가진데, 첫 번째는 갱신하는 트랜잭션의 롤백 시 갱신 전으로 되돌리는 것이고, 두 번째는 복수의 트랜잭션으로부터 격리 수준에 따라 대응하는 갱신 데이터를 참조하는 데 이용한다(같은 행을 갱신할 때마다 UNDO 로그가 작성되어 같은 행에 대한 복수 버전이 존재하며 이에 의해 1과 2를 실현하고 있다).


### 트랜잭션 격리 수준별 외관
MySQL 트랜잭션 격리 수준의 기본값은 '반복 읽기(RR, Repeatable Read)'이다.


한 개의 커넥션에서 쓰기를 해서 트랜잭션 격리 수준이 다른 2개의 커넥션에서 어떻게 보일지 알아보자. Transaction A는 REPEATABLE READ(반복 읽기), Transaction B는 READ COMMITTED(커밋된 읽기)이다:
```
// 1. Transaction A와 B의 격리 수준을 각각 변경하고 시작한다.
Transaction A> set transaction isolation level repeatable read; start transaction;
Transaction B> set transaction isolation level read committed; start transaction;

// 2. Transaction C를 시작하고 명령을 입력한다.
Transaction C> start transaction;
Transaction C> update t1 set v2 = 'MySQL' where i1 = 1; commit; start transaction;

// 3. Transaction A와 B에서 각각의 명령을 입력한다.
Transaction A> select * from t1 where i1 = 1;
+----+-------+
| i1 | v2    |
+----+-------+
|  1 | MySQL |
+----+-------+

Transaction B> select * from t1 where i1 = 1;
+----+-------+
| i1 | v2    |
+----+-------+
|  1 | MySQL |
+----+-------+

// 4. Transaction C에서 명령을 입력한다.
Transaction C> update t1 set v2 = 'PostgreSQL' where i1 = 1; commit; start transaction;

// 5. Transaction C, A, B 순으로 각각의 명령을 입력한다.
Transaction C> update t1 set v2 = 'Oracle' where i1 = 1;
Transaction A> select * from t1 where i1 = 1;
+----+-------+
| i1 | v2    |
+----+-------+
|  1 | MySQL |
+----+-------+

Transaction B> select * from t1 where i1 = 1;
+----+------------+
| i1 | v2         |
+----+------------+
|  1 | PostgreSQL |
+----+------------+

Transaction C> select * from t1 where i1 = 1;
+----+--------+
| i1 | v2     |
+----+--------+
|  1 | Oracle |
+----+--------+

// 6. Transaction A, B, C 순으로 각각의 명령을 입력한다.
Transaction A> rollback;
Transaction B> rollback;
Transaction C> rollback;
```

#### 반복 읽기
반복 읽기는 최초 쿼리를 실행한 시점에 커밋된 데이터를 읽어 들인다. 이 시점에서는 커밋된 읽기와 같다. 같은 커리를 복수 회 실행하면 최초 읽은 내용의 결과 세트가 반환된다. 복수 회의 쿼리 실행 사이에 다른 트랜잭션이 커밋햇어도 그 내용은 반영되지 않는다.
```
Transaction A> select * from t1 where i1 = 1; // 3의 결과는 1과 'MySQL'
Transaction A> select * from t1 where i1 = 1; // 5의 결과도 1과 'MySQL'
```


#### 커밋된 읽기
커밋된 읽기는 쿼리를 실행한 시점에서 커밋된 데이터를 읽어 들인다. 같은 쿼리를 복수 회 실행하면 그사이에 다른 트랜잭션에서 커밋할 때가 있는데, 이 경우 최신 쿼리의 실행 개시 시점에서 커밋된 데이터를 읽는다.
```
Transaction B> select * from t1 where i1 = 1; // 3의 결과는 1과 'MySQL'
Transaction B> select * from t1 where i1 = 1; // 5의 결과는 1과 'PostgreSQL'
```


#### 갱신을 수행하는 트랜잭션 자신
갱신을 수행하는 트랜잭션 자신은 트랜잭션 격리 수준이나 COMMIT/ROLLBACK에 상관없이 자신이 수행했단 갱신을 즉시 볼 수가 있다.
```
Transaction C> select * from t1 where i1 = 1; // 5의 결과는 1과 'Oracle'
```


![select * from t1 where i1 = 1로 보이는 행](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/트랜잭션과%20동시성%20제어%20-%20복수의%20쿼리%20통합/images/select%20*%20from%20t1%20where%20i1%20%3D%201로%20보이는%20행.jpg)


#### 커밋되지 않은 읽기가 사용되지 않는 이유
MVCC에서는 이 격리 수준이 별로 필요가 없어서 사용하는 사례가 적은 이유도 있지만, 여기에는 다른 이유가 있다.


현재는 MVCC가 주류라고 할 수 있지만, Oracle이나 Firebird가 구현된 시점에서는 주류가 아니었다. 그 당시 많은 데이터베이스가 잠금을 어떤 단위(테이블, 블록, 행)로 획득하는 방식에서 트랜잭션의 고립성을 담보하고 있었다. 이 경우 읽기의 시점에 따라 읽기가 블록되는 경우가 있다. 이때 커밋되지 않은 읽기를 이용하면 읽기가 블록되지 않으므로 그 순간의 대략적인 값을 알 수 있어 매우 편리했다.


하지만 MVCC를 이용하면 읽기가 블록되는 경우가 없어서 커밋되지 않은 읽기가 필요하지 않아졌다.


&nbsp;
## 잠금 타임아웃과 교착 상태가 발생하는 이유
### 잠금 타임 아웃이란
'갱신'과 '참조'는 서로를 블록하지만, '갱신'과 '갱신'이 부딪치는 경우에는 나중에 온 갱신이 잠금 대기 상태가 된다. 잠금을 건 쪽이 언제 잠금을 풀지 알 수 없어서 잠금 해제를 기다리고 있는 쪽에서는 잠금을 기다리거나 기다리지 않거나, 기다린다면 어느 정도 기다릴지를(초수 지정이나 무한으로 기다린다) 설정할 수 있다. 


MySQL의 경우에는 'innodb_lock_wait_timeout'이란 시스템 변수로 다음과 같이 설정할 수 있다. 다만 기다리지 않는 설정은 없어서 유효값은 '1'(초) 이상이어야 한다.
```
set innodb_lock_wait_timeout = 1;
```


이때 잠금 대기로 타임아웃이 발생하는 경우 DBMS로부터 롤백되는 단위가 다를 때가 있는데, 해당 트랜잭션 전체를 롤백하는 경우와 쿼리만 롤백하는 것이다. MySQL에서는 잠금 대기로 타임아웃이 발생하면 롤백되는 것은 기본으로 오류가 발생한 쿼리이다. 트랜잭션 전체를 롤백하고 싶다면 다음 방법으로 할 수 있다.
* 타임아웃 오류 후 명시적으로 ROLLBACK을 실행한다.
* innodb_rollback_on_timeout 시스템 변수를 설정한다.


잠금 타임아웃 만들기:
```
Transaction A> set innodb_lock_wait_timeout = 5;
Transaction A> start transaction;
Transaction B> start transaction;
Transaction B> insert into t1 values(4, 'Oracle');
Transaction A> insert into t1 values(4, 'JavaDB');
// 이 오류 메시지가 표시된다.
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction 
```


### 교착 상태란
예를 들어, 트랜잭션 A가 테이블 a의 잠금을 얻고 트랜잭션 B가 테이블 b의 잠금을 얻었다면


![교착 상태 전](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/트랜잭션과%20동시성%20제어%20-%20복수의%20쿼리%20통합/images/교착%20상태%20전.jpg)


이 잠금을 유지한 채 서로 잠금을 건 자원에 잠금이 필요한 처리(INSERT/UPDATE/DELETE)를 실행하면 아무리 기다려도 상황이 바뀌지 않는 상태가 된다. 이것을 '교착 상태'라고 한다.


![교착 상태](https://github.com/0jun0815/YJStudy/blob/master/데이터베이스/트랜잭션과%20동시성%20제어%20-%20복수의%20쿼리%20통합/images/교착%20상태.jpg)


교착 상태 만들기:
```
Transaction A> create table a(i1 int not null primary key, v2 varchar(20)) engine = innodb;
Transaction A> create table b(i1 int not null primary key, v2 varchar(20)) engine = innodb;
Transaction A> set innodb_lock_wait_timeout = 50; start transaction;
Transaction B> start transaction;
Transaction A> insert into a values(1, 'Firebird');
Transaction B> insert into b values(1, 'MySQL');
Transaction A> insert into b values(1, 'Firebird');
Transaction B> insert into a values(1, 'MySQL');
// 이 오류 메시지가 표시된다.
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
```


### 교착 상태의 빈도를 낮추는 대책
잠금 타임아웃은 일정 시간 기다리면 상황이 개선될(잠금을 건 곳에서 잠금을 푼다) 가능성이 있지만, 교착 상태는 상황이 개선될 가능성이 없다. 이 때문에 일반적인 DBMS에서는 교착 상태를 독자적으로 검출해 교착 상태를 보고한다.


MySQL도 교착 상태가 일어나면 이를 즉시 인식해 시스템에 영향이 작은 쪽의 트랜잭션을 트랜잭션 개시 시점까지 롤백한다.


교착 상태의 발생 빈도를 낮추려면 다음 사항을 고려해야 한다.


#### DBMS 전반적인 대책
1. 트랜잭션을 자주 커밋한다. 이에 따라 트랜잭션은 더 작은 단위가 되어 교착 상태의 가능성을 낮춘다.
2. 정해진 순서로 테이블(그리고 행)에 액세스하게 한다. 예를 들어, 앞의 교착 상태의 예에서는 트랜잭션 A가 [테이블 a -> 테이블 b] 순으로 액세스했고 트랜젝션 B가 [테이블 b -> 테이블 a] 순으로 액세스하고 있는데, 이를 어느 트랜잭션이라도 [테이블 a -> 테이블 b] 처럼 동일한 순서로 액세스하게 한다.
3. 필요 없는 경우에는 읽기 잠금 획득(SELECT ~ FOR UPDATE 등)의 사용을 피한다.
4. 쿼리에 의한 잠금 범위를 더 좁히거나 잠금 정도를 더 작은 것으로 한다. 예를 들어, 행의 잠금을 사용할 수 있는 경우에는 사용한다. MySQL은 트랜잭션의 격리 수준을 되도록 '커밋된 읽기'로 한다(InnoDB의 기본 격리 수준은 반복 읽기).
5. 한 테이블의 복수 행을 복수의 연결에서 순서 변경 없이 갱신하면 교착 상태가 발생하기 쉽다. 동시에 많은 연결에서 갱신 때문에 교착 상태가 자주 발생한다면 테이블 단위의 잠금을 획득해 갱신을 직렬화하면 동시성은 떨어지지만 교착 상태는 회피할 수 있어서 전체 처리로 보면 좋은 예도 있다.


#### MySQL(InnoDB)의 대책
6. 테이블에 적절한 인덱스를 추가해 쿼리가 이를 이용하게 한다. 인덱스가 사용되지 않는 경우에는 필요한 행의 잠금이 아닌 스캔한 행 전체에 대해 잠금이 걸리게 된다.


&nbsp;
## 해서는 안 되는 트랜잭션 처리
### 주의1. 오토커밋
MySQL에서는 새로운 연결은 모두 기본값으로 오토커밋이 실행된다. '오토커밋'이란 쿼리 단위로 커밋하는 설정인데, 이 설정은 MySQL 커맨드라인 클라이언트 같은 대화형 도구를 사용해 간단한 쿼리의 실행과 테스트를 하는 경우에는 편리하지만, 애플리케이션의 잠금을 실행하는 데는 커밋의 부하가 너무 높다. 


일정 수 이상의 갱신(UPDATE/INSERT/DELETE)을 수행하는 처리나 트랜잭션의 기능(복수의 쿼리를 정리해 커밋과 롤백한다. 여러 번 실행하는 SELECT로 애매한 읽기나 팬텀을 막는다)등은 적절한 단위와 트랜잭션 격리 수준에서 트랜잭션을 이용해 오토커밋을 사용하지 않도록 한다.


### 주의2. 긴 트랜잭션
긴 트랜잭션은 데이터베이스 트랜잭션의 동시성이나 자원의 유효성을 저하한다. 갱신을 포함한 트랜잭션은 같은 테이블과 행을 갱신하려는 다른 트랜잭션을 블록하고 이것이 장시간 이어지면 블록된 트랜잭션을 타임아웃시킨다. 또한, 이 잠금과 블록 사이에 교차가 발생하면 교착 상태가 되고 긴 트랜잭션 중 하나가 롤백될 수 있다. 


이러한 상황을 피하려면 교착 상태의 빈도를 낮춰야 하고 그 외에도 다음과 같은 사항을 주의하면 좋다.


#### 대량 처리를 한 개의 트랜잭션이 실행한다
대량의 갱신 처리를 한 개의 트랜잭션으로 실행하면 트랜잭션으로 이 대량 갱신 처리를 롤백하기 위한 대량의 UNDO 로그를 트랜잭션 종료까지 유지해야 한다. UNDO 로그가 불필요해진 시점에 해당 영역은 해제되어 재사용되지만, OS의 파일 시스템에서의 크기는 줄어들지 않는다. 이를 막기 위해 대량 처리는 적당한 크기의 트랜잭션으로 나눠서 실행하는 것을 추천한다.


#### 아무것도 하지 않는 트랜잭션을 유의한다
한 번 테이블을 SELECT하고 나서 아무것도 하지 않고 트랜잭션을 열린 채로 두면 어떻게 될까? 같은 테이블에 갱신을 실행할 때 이 테이블의 반복 읽기를 유지하기 위해 UNDO 로그가 계속 유지된 상태가 되고 만다.


#### 트랜잭션 중에 대화 처리를 넣는다
일반적인 DBMS의 트랜잭션은 매우 빡빡한 처리를 동시에 실행할 수 있는 구조를 갖추고 있다. 이것을 효율적으로 다루려면 트랜잭션은 되도록 작게 하고 트랜잭션을 구성하는 내용에는 언제 끝날지를 알 수 없는 불명확한 처리를 포함해서는 안된다.


사용자와의 대화 처리는 일반적인 트랜잭션에서 액션과 비교하면 매우 커서 타임아웃을 설정하지 않는 한은 끝없이 사용자의 처리를 기다리게 되고, 결국 시스템 전체의 효율을 떨어뜨리게된다. 이러한 처리는 트랜잭션 내에 넣지 않아야 하고, 어쩔 수 없이 넣는 경우에도 반드시 상한을 정해서 무한으로 기다리는 일이 없도록 해야 한다.


#### 처리 능력 이상의 트랜잭션 수
트랜잭션의 실행이 다른 트랜잭션의 잠금 때문에 막힌다면 잠금 타임아웃이나 교착 상태의 확률이 증가하고 이는 성능 저하로 이어진다.


커넥션이 잘 작동하는 수나 동시 실행할 수 있는 수의 상한을 어느 정도로 설정해야 할지는 시스템의 요건(갱신이 많은가, 검색이 많은가)이나 하드웨어 성능에도 좌우되므로 최적의 트랜잭션 수는 부하 실험을 수행해 측정하는 수밖에 없다. MySQL에서는 데이터베이스 서버의 커넥션 수 상한을 설정하는 'max_connections'이라는 시스템 변수가 있어서 이것으로 조절할 수 있다.


&nbsp;
&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [데이터베이스 첫걸음](http://book.naver.com/bookdb/book_detail.nhn?bid=11154846)

