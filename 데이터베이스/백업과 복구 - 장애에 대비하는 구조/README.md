# 백업과 복구 - 장애에 대비하는 구조


* [지속성과 성능이 양립하는 구조](#지속성과-성능이-양립하는-구조)


&nbsp;      
## 지속성과 성능이 양립하는 구조
### DBMS의 3가지 구조
트랜잭션에는 'ACID'라는 특성이 있다. ACID의 'D'는 지속성(Durability)으로, 일련의 데이터 동작(트랜잭션 동작)을 완료(COMMIT)하고 통지를 사용자가 받은 시점에서는 그 동작이 '영속화'되어 결과를 잃어버리지 않는 것을 나타낸다. 이는 시스템이 정상일 때뿐만 아니라 데이터베이스 서버나 OS의 비정상적 종료 등의 시스템 장애에 견딜 수 있다는 걸 의미한다.


DBMS에서 데이터를 보존하는 기억장치는 대부분 하드디스크이다. 하드디스크에서 지속성을 실현하려면 쓰기를 전부 '동기화 쓰기'로 하면 좋겠지만, 데이터베이스의 쓰기는 기억장치의 임의 장소에 무작위로 액세스해서 쓰기를 수행하기 때문에 동기화 쓰기는 느려서 성능 면에서 실용적이지 않다. 그래서 지속성과 성능이 양립하도록 일반적으로 DBMS에서는 다음 구조를 사용한다.
* 로그 선행 쓰기
* 데이터베이스 버퍼
* 크래시 복구


#### 로그 선행 쓰기
로그 선행 쓰기(WAL, Write Ahead Log)의 기본 개념은 데이터베이스의 데이터 파일 변경을 직접 수행하지 않고, 우선 로그로 변경 내용을 기술한 로그 레코드를 써서 동기화하는 구조이다. MySQL에서는 이 로그를 'InnoDB 로그'로 부른다.


WAL에는 다음과 같은 이점이 있다:
1. 디스크에 연속해서 쓰기 때문에 무작위로 쓰는 것보다 성능이 좋다.
2. 디스크에 쓰는 용량과 횟수를 줄일 수 있다.
3. 데이터베이스 버퍼를 이용해 데이터베이스의 데이터 파일로의 변경을 효율성 높게 수행한다.


#### 데이터베이스 버퍼
커밋 시에는 WAL에 변경 내용을 쓰기 때문에 데이터 파일의 변경 내용은 트랜잭션이 커밋되면서 동시에 동기화할 필요가 없다. 그렇다고 트랜잭션마다 버퍼를 취해 비동기적인 쓰기를 하면 로그와 데이터 파일 간 일관성을 유지하기가 어렵다.


그래서 일반적인 DBMS에서는 '데이터베이스 버퍼'를 준비해 데이터 파일로의 입력을 데이터베이스 버퍼 경유로 일원화해서 단순화하고 있다. 이 때문에 효율적으로 데이터의 일관성을 유지할 수 있게 된다. 


MySQL의 경우 갱신의 흐름은 다음과 같다:
1. 갱신 대상의 데이터를 포함한 페이지가 버퍼 풀에 있는지를 확인하고 없다면 데이터 파일로부터 읽어 들인다.
2. 버퍼 풀의 해당 페이지에서 갱신을 수행한다.
3. 2의 갱신 내용이 커밋과 함께 로그에 기록된다. 버퍼 풀에 갱신되었지만, 아직 데이터 파일에 써지지 않은 페이지는 버퍼 풀 내에서 더티페이지로 다룬다.
4. 데이터 페이지는 나중에 적당한 타이밍에 정리되어 데이터 파일로 써진다(이것을 '체크포인트'라고 부른다).
5. 4의 체크포인트 이전 로그 파일을 분필요해진다. 또한, 갱신과 더불어 1부터 순서가 반복된다.


보통은 데이터 갱신 시 이 사이클을 반복한다. WAL과 버퍼 풀에 갱신을 반영해가며 데이터 파일보다 앞질러가는 형태가 되며, 체크포인트에서 데이터 파일이 수정사항을 따라잡고 WAL과 버퍼 풀이 선행해서 수정하기를 반복한다.


![버퍼 풀과 데이터 파일, 로그]()


> MySQL에서는 데이터베이스 버퍼를 '(InnoDB) 버퍼 풀'이라고 부른다.


> 더티 페이지(Dirth Page)는 일반적으로 메모리로 읽어서 갱신된 페이지를 가리킨다. 


#### 크래시 복구
크래시(Crash)가 발생한 경우 어떻게 복구할까?


크래시가 발생하면 다음과 같은 상태가 된다:
1. WAL: 마지막으로 커밋된 트랜잭션의 갱신 정보를 가진다.
2. 데이터베이스 버퍼: 크래시로 내용이 전부 소실된다.
3. 데이터베이스 파일: 최후 체크포인트까지의 갱신 정보를 가진다.


크래시 이후 MySQL 서버를 재시작하면 3과 1의 체크포인트 이후 갱신 정보를 사용해 데이터베이스 파일을 크래시 때까지 커밋된 최신 상태로 수정한다. 이 동작을 '롤 포워드(Roll-Forward)'라고 한다.


![크래시일 때 로그 동작]()


MySQL 서버를 재시작하는 것으로 복구할 수 있는 구조가 놀랍기는 하지만, 이와 같은 구조도 논리적인 파괴(DDL 문에 따른 테이블의 파기 등)나 물리적인 파손(디스크 장치의 고장 등)에는 대응할 수 없다. 이와 같은 파손이나 파괴에 대응하려면 정상적으로 동작하고 있을 때 주기적으로 백업하고 이를 이용해 복원이나 복구하는 것이 좋다.


&nbsp;
&nbsp;      
### [by. 0junChoi](https://github.com/0jun0815) email: <0jun0815@gmail.com>
### 출처: [데이터베이스 첫걸음](http://book.naver.com/bookdb/book_detail.nhn?bid=11154846)

